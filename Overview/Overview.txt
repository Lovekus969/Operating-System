 Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional PC and server operating systems and operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these chapters. Therefore, they are suitable for individual readers or for students in
lower-level classes who want to learn what an operating system is without
getting into the details of the internal algorithms.


READ:
File/Device ──▶ Kernel ──▶ User Buffer

WRITE:
User Buffer ──▶ Kernel ──▶ File/Device

Process management. Chapters 3 through 5 describe the process concept
and concurrency as the heart of modern operating systems. A process is
the unit of work in a system. Such a system consists of a collection of
concurrently executing processes, some executing operating-system code
and others executing user code. These chapters cover methods for process
scheduling and interprocess communication. Also included is a detailed
discussion of threads, as well as an examination of issues related to multicore systems and parallel programming.

 Process synchronization. Chapters 6 through 8 cover methods for process
synchronization and deadlock handling. Because we have increased the
coverage of process synchronization, we have divided the former Chapter
5 (Process Synchronization) into two separate chapters: Chapter 6, Synchronization Tools, and Chapter 7, Synchronization Examples.

• Memory management. Chapters 9 and 10 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
